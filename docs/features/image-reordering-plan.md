# Image Reordering (Drag-and-Drop) — Design Plan

## Overview

Add drag-and-drop reordering of images so users can control the display order. The order updates immediately in the editor preview and persists with the survey data. This builds on the existing image upload architecture documented in `docs/features/image-upload-architecture.md`.

## Goals

- Reorder images within a logical group (e.g., report details “money shot”, front elevation, element-level images, component-level images).
- Provide intuitive drag-and-drop on desktop and touch-friendly interactions on mobile.
- Reflect the new order in the editor preview generated by `app/home/editor/hooks/useEditorState.tsx:1`.
- Persist order with the survey content (no server schema changes required initially).

## Scope

- In-scope
  - Drag-and-drop ordering for active (non-archived) images shown by `DropZoneInputImageV2`.
  - Round-trip order via RHF-controlled values so survey content preserves image arrays in the chosen order.
  - Live preview updates in the editor when image order changes.
- Out-of-scope (initial)
  - Server/DynamoDB sort fields for images (can be added later if needed).
  - Cross-group moves (e.g., moving images between distinct path groups via drag). Only reorder within the visible group.
  - Archived list reordering.

## Key Integration Points

- `app/home/components/InputImage/DropZoneInputImageV2.tsx:1`

  - Render images in a sortable list using `@dnd-kit/sortable`.
  - Maintain the displayed order from a controlled `value` when provided.
  - Emit `onReorder` with the new ordered array.

- `app/home/components/InputImage/RhfDropZoneInputImage.tsx:1`

  - Bridge RHF field value to `DropZoneInputImageV2` via new `value` and `onReorder` props.
  - Ensure uploads append to the end; delete/archive remove from the value.

- Editor preview

  - No code change required; `mapFormDataToHtml` preserves the order in `SurveyImage[]` so the editor renders images in the same order as stored in the survey content.

- `app/home/editor/utils/formData.tsx:86`
  - No changes required; it maps arrays to HTML in-place and preserves order.

## Data Model and State

- Persist order in the survey JSON by keeping image arrays (`SurveyImage[]`) in the desired order:
  - `app/home/surveys/building-survey-reports/BuildingSurveyReportSchema.ts:65` — `ReportDetails.moneyShot`
  - `app/home/surveys/building-survey-reports/BuildingSurveyReportSchema.ts:66` — `ReportDetails.frontElevationImagesUri`
  - `app/home/surveys/building-survey-reports/BuildingSurveyReportSchema.ts:116` — `ElementSection.images`
  - `app/home/surveys/building-survey-reports/BuildingSurveyReportSchema.ts:135` — `Inspection.images`
- No changes to `ImageMetadata` schema in `app/home/clients/Database.ts:1` are required for the first iteration. The global image store remains responsible for upload/metadata; ordering is contextual to each survey’s content arrays.

## UX and Interaction

- Desktop
  - Drag handle visible on each thumbnail; drag to reorder within the grid/row.
  - Smooth animation with collision detection suitable for grids.
  - Drop commits new order; brief toast or subtle check icon confirmation.
- Mobile
  - Long-press (≈500ms) to initiate drag; larger handle area.
  - Maintain 60fps during drag; avoid expensive reflows.
- Accessibility
  - Keyboard reordering: focus handle, use arrow keys to move item; announce position changes to screen readers.
  - Respect reduced motion.

## Component/API Changes

1. DropZoneInputImageV2

- New props

  - `value?: DropZoneInputFile[]` — Optional controlled list used for display order.
  - `onReorder?: (files: DropZoneInputFile[]) => void` — Called after drag end with new order.
  - `enableReorder?: boolean` — Default `true`; toggles drag UI.
  - `dragHandleAriaLabel?: string` — Accessibility label for the handle.

- Behavior

  - If `value` is provided, render images in that order. If absent, fallback to internally discovered files order but prefer to emit initial `onChange` to seed the form value.
  - Only active images are sortable; archived images are listed separately (non-sortable).
  - On upload success, append new image to the end (maintain order semantics users expect).
  - On delete/archive, remove from the active list and update `onChange`/`onReorder` accordingly.

- Implementation outline (high level)
  - Wrap active thumbnails with `DndContext` and `SortableContext` from `@dnd-kit/sortable`.
  - Use `rectSortingStrategy` or a grid-friendly strategy; use `arrayMove` to compute the new ordered array in `onDragEnd`.
  - Provide a visible drag handle within `Thumbnail` or the container; pass `attributes`/`listeners` to the handle.

2. RhfDropZoneInputImage

- Map RHF `field.value` to `DropZoneInputImageV2.value`.
- Implement `onReorder` to call `field.onChange` with the updated array.
- Ensure existing `onChange` from uploads also updates the RHF array value and preserves order.

3. Editor (preview)

- No change needed; preview reflects ordering because arrays are rendered in order by `mapFormDataToHtml`.

## Pseudocode Snippets

- Reorder handler inside `DropZoneInputImageV2`

```tsx
// onDragEnd pseudo
const handleDragEnd = ({ active, over }) => {
  if (!over || active.id === over.id) return;
  const oldIndex = files.findIndex((f) => f.path === active.id);
  const newIndex = files.findIndex((f) => f.path === over.id);
  const next = arrayMove(files, oldIndex, newIndex);
  setFiles(next);
  onReorder?.(next.filter((f) => !f.isArchived));
  onChange?.(next.filter((f) => !f.isArchived));
};
```

- RHF wiring

```tsx
<DropZoneInputImage
  path={path}
  value={field.value}
  onReorder={field.onChange}
  onChange={field.onChange}
  enableReorder
  features={{ archive: true, metadata: true }}
/>
```

## Editor Preview Flow

- `mapFormDataToHtml` preserves array order (`app/home/editor/utils/formData.tsx:86`), so reordering within the form is reflected naturally in the preview with no additional code.

## Testing Plan

- Unit tests

  - Drop reorder event updates order (use `arrayMove` expectation).
  - Upload appends to end; delete removes item and compacts order.
  - Archived items are excluded from the sortable list and do not affect indices.
  - RHF integration: `onReorder` updates `field.value` and re-renders in new order.

- Integration tests

  - Reorder “money shot” and verify preview order changes in the editor (assert via rendered image sequence in HTML output from `mapFormDataToHtml`).
  - Reorder element-level and component-level images and confirm persistence in survey content via `surveyStore.update`.

- Accessibility
  - Keyboard drag simulation using `@dnd-kit` keyboard sensor to verify ARIA announcements and index changes.

## Migration/Backwards Compatibility

- No schema changes required. Existing surveys will simply adopt the array order captured by the form controls.
- If a future iteration needs a canonical order per image-path independent of survey content, add an optional `sortKey` field in the local Dexie `ImageMetadata` and maintain it per `path` (requires a Dexie schema bump and a light migration). Not needed for v1.

## Risks and Mitigations

- Inconsistent sources of truth (store vs form value)
  - Mitigation: When `value` is provided, always render strictly from `value`. Use store only for hydration and thumbnail metadata.
- Performance on large lists
  - Mitigation: Virtualization is likely unnecessary for typical counts; use optimized sensors and avoid heavy work in `onDragOver`.
- Preview not updating
  - Mitigation: Switch to `surveyStore.useGet` in the editor hook so changes propagate automatically.

## Implementation Steps

1. Add sortable behavior to `DropZoneInputImageV2` with new props and DnD wiring.
2. Wire `RhfDropZoneInputImage` to pass `value` and handle `onReorder`.
3. Add unit tests for reorder logic and RHF integration under `app/home/components/InputImage/__tests__`.
4. Add an integration test to verify editor preview reflects the new order.

## Acceptance Criteria

- Users can drag to reorder active images; archived images remain separate and non-sortable.
- The new order persists in survey content (via RHF) and remains stable across reloads.
- Editor preview updates to match the new order without manual refresh.
- No regressions in upload, archive, or metadata editing flows.
